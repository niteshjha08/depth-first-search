/**
 * @file mouse.h
 * @author Nitesh Jha (niteshj@umd.edu), Anish Mitra (amitra12@umd.edu), Naveen Mangla (nmangla@umd.edu)
 * @brief 
 * @version 0.1
 * @date 2021-11-13
 * 
 * @copyright Copyright (c) 2021
 * 
 */

#ifndef MICROMOUSE_H
#define MICROMOUSE_H

#include "../node/node.h"
#include "../util/util.h"
#include <array>
#include<vector>
#include<stack>
#include<iostream>

namespace rwa2 {
    /**
     * @brief This class is used to compute a path and execute the path.
     *
     */
    class Mouse {
        public:

        /**
         * @brief Construct a new MicroMouse object
         *
         * The robot is always at (0,0) and facing NORTH when the simulator starts
         */
        Mouse() :m_x{ 0 }, m_y{ 0 }, m_direction{ direction::NORTH }{
            
            //initialize the maze by placing around the perimeter of the maze
            for (int x = 0; x < m_maze_width; x += 1) {
                for (int y = 0; y < m_maze_height; y += 1) {
                    m_maze.at(x).at(y).set_wall(direction::NORTH, (y == m_maze_height - 1));
                    m_maze.at(x).at(y).set_wall(direction::EAST, (x == m_maze_width - 1));
                    m_maze.at(x).at(y).set_wall(direction::SOUTH, (y == 0));
                    m_maze.at(x).at(y).set_wall(direction::WEST, (x == 0));
                }
            }
        }
        /**
         * @brief Visually sets boundary walls in the simulator
         * 
         */
        void display_walls();

        /**
         * @brief Make the mouse move forward
         *
         */
        void move_forward();

        /**
         * @brief Make the mouse rotate 90 deg CCW
         *
         */
        void turn_left();

         /**
         * @brief Make the mouse rotate 90 deg CW
         *
         */
        void turn_right();


        /**
         * @brief Implement DFS to compute and generate a path between 2 nodes in a maze
         *
         * @param goal_x x-coordinate of the goal cell
         * @param goal_y y-coordinate of the goal cell
         *
         * @return true A path is found
         * @return false A path is not found
         */
        bool search_maze(int goal_x, int goal_y);


        /**
         * @brief Checks if a particular node is a node visited earlier
         *
         * @param x x-coordinate of cell
         * @param y y-coordinate of cell
         *
         * @return true Node is visited
         * @return false Node has not been visited
         */
        bool is_visited(int x, int y);
        

        /**
         * @brief  Checks if cell has a pathway to traverse
         * in a particular direction for given coordinates x and y
         *
         * @param x x-coordinate of the current cell
         * @param y y-coordinate of the current cell
         * @param direction Direction to traverse in : 'n', 'e', 's', 'w'
         *
         * @return true If there is a pathway to traverse in 'direction'
         * @return false If there is no pathway to traverse in 'direction'
         */
        bool is_valid(int x, int y, int direction);

        
        /**
         * @brief Method to align the MOUSE to the required orientation
         *
         * @param direction Required direction to align : 'n','e','s','w'
         *
         */
        void align_direction(int direction);


        /**
         * @brief Method for mouse to move a step and check for walls at each step
         * 
         * @param x x-coordinate of the next step from the current x-coordinate of the mouse
         * @param y y-coordinate of the next step from the current y-coordinate of the mouse
         *
         * @return true If mouse moves to the next step
         * @return false If mouse encounters a wall 
         */
        bool move_path_step(int x, int y);


        /**
         * @brief Method to trace the path generated by the search_maze() function
         * at every step
         *
         * @return true Mouse reaches the goal 
         * @return false If move_path_step() fails
         */
        bool trace_path();


        /**
         * @brief Method to set the goal coordinates
         *
         * @param x x-coordinate of the goal cell
         * @param y y-coordinate of the goal cell 
         */
        void set_goal(int x, int y);


        /**
         * @brief Get the position of the mouse
         * 
         * @return std::array<int, 2> 
         */
        std::array<int, 2> get_position();

        /**
         * @brief Modifies the maze upon discovering a new wall by the mouse in motion
         * 
         * @param x x-coordinate of the wall location
         * @param y y-coordinate of the wall location
         * @param direction direction of the wall in the node
         */
        void modify_maze(int x,int y, int direction);
        
        
        
        private:
            std::vector<std::array<int, 2>> visited{}; //vector to store the list of nodes visited
            std::stack<std::array<int, 2>> s{}; 
            static const int m_maze_width{ 16 }; //width of the maze
            static const int m_maze_height{ 16 };//height of the maze
            std::array<std::array<Node, m_maze_width>, m_maze_height> m_maze; //2D array maze object
            int goal_x; //x-coordinate of the goal
            int goal_y; //y-coordinate of the goal
            int m_x ; //x position of the robot in the maze
            int m_y ; //y position of the robot in the maze
            int m_direction; //direction of the robot in the maze
        
    };
};
#endif